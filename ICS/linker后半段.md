# linker后半段
## 可执行目标文件

可执行文件是完全链接的 所以不需要rel节
### 程序头部表
Align是程序头部指定的对齐

1、2行代码段：

vaddr/paddr 代码段的开始地址

Memsz 总共的内存大小 

Filesz 被初始化为可执行目标文件的头的字节数

3、4行数据段：

Off 便宜的地址，从偏移了。。。开始初始化

Filesz 初始化的字节大小

该段中剩下的（memsz-filesz）对应于被初始化为0的.bss的数据
### 加载可执行目标文件

运行可执行目标文件  ./prog 

Execve函数调用加载器，加载器把可执行目标文件的代码和数据从磁盘复制到内存中，这个过程叫做加载

### 与静态库链接
#### 最初的做法：
将所有的标准c函数放在一个单独的可重定位目标模块中，再将其链接到可执行文件中

gcc main.c _usr_lib/libc.o

但是其耗时且浪费空间，逐一链接又出错且消耗时间

#### 静态库
相关的函数被编译成独立的目标模块，静态库以存档的格式 .a结尾存在磁盘中。
要生成静态库，则
gcc -c x1.c x2.c

ar ris xxx.a x1.o x2.o

就用sr指令生成了xxx.a这个静态库

关于库的准则是把它们放在命令行的结尾，**被调用的库还要放到最后面**
### 动态链接共享库
共享库是一个目标模块，可以加载到任何地址，这个链接方式叫动态链接，dynamic linking。
#### 链接方式 
一个库只有一个.so文件 

gcc -shared -fpic -o xxx.so x1.c x2.c创建一个叫xxx.so的库，里面包含x1.c和x2.c

其中-fpic指示编译器生成与位置无关的代码

-shared 指示链接器创建一个共享的目标文件

gcc -o prog21 main2.c ./libvector.so

这样建立了可执行目标文件prog21
### 动态链接和静态链接的区别
静态链接方法：#pragma comment(lib, “test.lib”) ，静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来
静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库

动态链接方法：LoadLibrary()/GetProcessAddress()和FreeLibrary()，使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序。

**动态库：**
1.共享：多个应用程序可以使用同一个动态库，启动多个应用程序的时候，只需要将动态库加载到内存一次即可；

2.开发模块好：要求设计者对功能划分的比较好。 

**静态库：**代码的装载速度快，执行速度也较快，因为编译时它只会把你需要的那部分链接进去，应用程序相对比较大。但是如果多个应用程序使用的话，会被装载多次，浪费内存。
 参考：[静态链接与动态链接的区别【转】 - 我在地狱 - 博客园](https://www.cnblogs.com/dirge/p/6443317.html)
### 应用程序中加载和链接共享库
在运行时可以加载和链接一些库，用于程序分发等。

### 位置无关代码
可以加载而无需重定位的代码叫PIC位置无关代码

1.PIC数据引用

在数据段开始的位置建立GOT全局变量偏移表，记录该目标

2.PIC函数调用

Lazy binding 延迟绑定 将过程地址的绑定推迟到第一次调用该过程时
PLT过程链接表 每个条目负责调用一个具体的函数 PLT【1】调用系统启动函数
·跳转到PLT，进入对应的条目

·通过GOT进行简介跳转，第一次饮用时只是把控制传送给PLT的下一条指令

·把addvec的地址押入栈

·PLT【0】通过GOT【1】间接把动态链接起的一个参数压入栈中，通过GOT【2】间接跳转到动态链接器，，找到addvec的运行时为止，重写GOT【4】

第二次进入：1.进入对应的PLT ，如PLT【2】，2.直接对应的GOT，如GOT【4】运行
