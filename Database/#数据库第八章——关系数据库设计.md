#数据库第八章——关系数据库设计
## 关系模式
关系模式与关系的区别：关系模式描述了关系数据结构和语义，是关系的型。而关系是一个数据集合，是关系的值，是关系模式的一个关系实例。
## 第一范式 1NF
**如果一个域的元素被认为是不可分的单元，那么这个域是原子的。**

**如果R的所有属性的域都是原子的，那么它符合第一范式**

## 码和函数依赖
### 码

r(R) 指定一个关系模式，表示该模式是关系r的，R表示属性集

当属性集是超码时，我们用K表示，“K是r（R）的超码”

超码的条件：对r实例中的所有元组t1，t2，若t1！=t2，那么t1【K】！=t2【K】
### 主属性
一个属性存在于任意的候选码中，这个属性是主属性
### 求候选码的简单方法
求候选码的简单方法方法： 
（1）如果有属性不在函数依赖集中出现，那么它必须包含在候选码中；
（2）如果有属性不在函数依赖集中任何函数依赖的右边出现，那么它必须包含在候选码中；
（3）如果有属性只在函数依赖集的左边出现，则该属性一定包含在候选码中。
（4）如果有属性或属性组能唯一标识元组，则它就是候选码；
参考：[如何求一个关系模式的候选码 - 一路前行 - CSDN博客](https://blog.csdn.net/weiyongle1996/article/details/73481163)
### 函数依赖
#### 概念：
对实例中的所有元组对t1，t2，若t1[$\alpha$]=t2[$\alpha$],则t1[$\beta$]=t2[$\beta$]，则该实例满足函数依赖$\alpha \rightarrow \beta$

若每个实例都满足函数依赖，则函数依赖在关系模式r（R）上成立

举例：若K$  \rightarrow  $R在r（R）成立，K是r（R）的一个超码
#### 依赖是平凡的
如果$\beta \subseteq \alpha那么\alpha \rightarrow \beta $是平凡的

#### 闭包closure

$F^+$ 表示F集合的闭包，能够从给定的F集合推导出的所有函数依赖的集合。包含F中所有的函数依赖。
#### 逻辑蕴含
F能推出 原不直观存在于 函数依赖集F 中的函数依赖 α→Β,则成α→Β被函数依赖集F逻辑蕴含

## 第二范式
![不满足第二范式](https://github.com/gogowhy/2019SE-NOTE/blob/master/IMAGES/database/%E4%B8%8D%E6%BB%A1%E8%B6%B3%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F.png)
### 定义
在第一范式的基础上，要求**非主属性都要和码有完全依赖**关系 ，所谓完全依赖是指不能存在仅依赖码一部分的属性，必须是依赖全部属性。（区别于部分依赖） 

如果有哪些数据只和码的一部份有关的话，它就不符合第二范式。同时可以得出：如果一个数据表的码只有单一一个字段的话，它就一定符合第二范式(前提是该数据表符合第一范式)。 

## BOYCE-CODD范式
### 定义
![不满足BC范式](https://github.com/gogowhy/2019SE-NOTE/blob/master/IMAGES/database/%E4%B8%8D%E6%BB%A1%E8%B6%B3BC%E8%8C%83%E5%BC%8F.png)
一、BCNF成立的条件是对F+中所有形如α →β的函数依赖，满足以下至少有一个成立：

1.α →β 是平凡的函数依赖

2.α 是模式R的一个超码

二、**存在着主属性对于码的部分函数依赖与传递函数依赖。**（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。

### 分解不属于BCNF的规则
我们用（α ⋃β）和（R-（β-α））来把这个关系模式分解

## 第三范式 3NF
### 定义
![不满足第三范式](https://github.com/gogowhy/2019SE-NOTE/blob/master/IMAGES/database/%E4%B8%8D%E6%BB%A1%E8%B6%B3%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F.png)
一、具有函数依赖集F的关系模式R属于3NF的条件：对于F+中所有形如α →β的函数依赖，一下至少一项成立：

1.α →β 是平凡的函数依赖

2.α 是模式R的一个超码

3.β-α的每个属性A都包含于R的一个候选码中

二、**任何非主属性不依赖于其它非主属性**。 (目的是实体拆分)

![满足第三范式](https://github.com/gogowhy/2019SE-NOTE/blob/master/IMAGES/database/%E6%BB%A1%E8%B6%B3%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F.png)
参考文章：[第一范式 第二范式 第三范式 BC范式 - abcde - CSDN博客](https://blog.csdn.net/asdfsadfasdfsa/article/details/83963046)

## 第四范式
要求把同一表内的多对多关系删除。
## 函数依赖理论
●自反律：若α为为一属性集且β⊆α，则有α→β。 

●增补律：若有α→β且λ为一属性集，则有λα→λβ。 

●传递律：若有α→β及β→λ，则有α→λ。 
派生的规则（简化计算），可由Armstrong推导出 

●合并律：若有α→β及α→λ，这则有α→βλ。 

●分解律：若有α→βλ，则有α→β及α→λ。 

●伪传递律：若有α→β及λβ→ σ ，则有α→σ。
参考：[关系数据库（范式判断、函数依赖、无损分解、正则覆盖） - 北极鱼 - CSDN博客](https://blog.csdn.net/sinat_27169251/article/details/51725980)

## 正则覆盖
###  无关属性
如果去除函数依赖中的一个属性不改变该函数依赖集的闭包，那么该属性是无关的。
### 正则覆盖定义
F的正则覆盖Fc是一个依赖集，使得F逻辑蕴含Fc中所有依赖，并且Fc逻辑蕴含F中的所有依赖，此外，F具有以下的性质：

1.Fc中的所有依赖不含无关属性

2.Fc中的左半部分是唯一的（没有两个依赖的左面是重复的）
## 无损分解
分解后没有属性丢失





